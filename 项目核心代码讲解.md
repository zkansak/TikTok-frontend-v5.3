# 项目核心代码讲解（面试用）

## 📌 一、无限滚动实现（重点）

### 代码位置：`src/hooks/useInfiniteScroll.js`

### 核心原理
使用 **IntersectionObserver API** 监听底部元素，当元素进入视口时自动加载更多数据。

### 关键代码片段

```javascript
// 创建 IntersectionObserver
const observerInstanceRef = new IntersectionObserver(
  (entries) => {
    const [entry] = entries;
    // 当底部元素进入视口，且还有更多数据时，触发加载
    if (entry.isIntersecting && hasMore && !loading) {
      const nextPage = page + 1;
      debouncedFetchMore(nextPage); // 防抖处理
    }
  },
  {
    threshold: 0.1,        // 10% 可见时触发
    rootMargin: '100px',  // 提前100px触发，优化体验
  }
);
```

### 面试讲解要点

1. **为什么用 IntersectionObserver？**
   - 性能更好，不阻塞主线程
   - 比监听 scroll 事件更精确
   - 浏览器原生支持，无需手动计算滚动位置

2. **防抖机制的作用**
   - 避免用户快速滚动时频繁触发请求
   - 提升性能和用户体验

3. **错误重试机制**
   - 网络失败时自动重试（最多3次）
   - 提升用户体验

---

## 📌 二、虚拟窗口机制（性能优化）

### 代码位置：`src/components/VideoFeed/VideoFeed.js` (182-209行)

### 核心原理
当视频列表很长时，只渲染可见区域附近的视频，减少DOM节点数量。

### 关键代码片段

```javascript
// 双向窗口策略：以当前可见索引为中心，保留前后各 maxItems/2 个项目
const displayedItems = useMemo(() => {
  if (!maxItems || state.feedList.length <= maxItems) {
    return state.feedList; // 如果总数小于窗口大小，全部渲染
  }

  const currentIndex = currentVisibleIndex;
  const windowSize = maxItems;
  const halfWindow = Math.floor(windowSize / 2);
  
  // 计算窗口范围
  let startIndex = Math.max(0, currentIndex - halfWindow);
  let endIndex = Math.min(state.feedList.length, startIndex + windowSize);
  
  // 如果接近末尾，调整起始位置
  if (endIndex === state.feedList.length) {
    startIndex = Math.max(0, endIndex - windowSize);
  }
  
  // 只返回窗口内的项目
  return state.feedList.slice(startIndex, endIndex);
}, [state.feedList, maxItems, currentVisibleIndex]);
```

### 面试讲解要点

1. **为什么需要虚拟窗口？**
   - 当列表有1000个视频时，全部渲染会导致DOM节点过多
   - 影响滚动性能和内存占用

2. **双向窗口策略**
   - 以当前可见视频为中心，保留前后各N个视频
   - 用户向上或向下滚动时，都能快速响应

3. **如何跟踪当前可见视频？**
   - 使用 IntersectionObserver 监听每个视频元素
   - 当视频进入视口中心区域时，更新 currentVisibleIndex

---

## 📌 三、自定义 Hooks（代码复用）

### 1. useInfiniteScroll
**位置**：`src/hooks/useInfiniteScroll.js`

**功能**：封装无限滚动逻辑

**使用示例**：
```javascript
const { observerRef, error, retry } = useInfiniteScroll(
  fetchMore,      // 加载更多数据的函数
  hasMore,        // 是否还有更多数据
  loading,        // 是否正在加载
  {
    threshold: 0.1,
    rootMargin: '100px',
    debounceDelay: 300,
  }
);
```

### 2. useFullscreenNavigation
**位置**：`src/hooks/useFullscreenNavigation.js`

**功能**：管理全屏模式下的视频切换

**核心功能**：
- 切换到下一个/上一个视频
- 防止快速连续切换（冷却机制）
- 管理切换动画状态

### 3. useSwipeGesture
**位置**：`src/hooks/useSwipeGesture.js`

**功能**：处理手势滑动（触摸和鼠标拖拽）

---

## 📌 四、状态管理（useReducer）

### 代码位置：`src/components/VideoFeed/VideoFeed.js` (13-59行)

### 核心原理
使用 `useReducer` 管理复杂的分页状态，比多个 `useState` 更适合。

### 状态结构
```javascript
const initialState = {
  feedList: [],      // 视频列表
  loading: true,     // 初始加载
  loadingMore: false, // 加载更多
  hasMore: true,     // 是否还有更多
  error: null,       // 错误信息
  page: 1,           // 当前页码
  pageSize: 10,      // 每页数量
};
```

### Action 类型
```javascript
// 开始加载
case 'FETCH_START':
  return { ...state, loading: true, error: null };

// 加载成功
case 'FETCH_SUCCESS':
  return {
    ...state,
    loading: false,
    feedList: [...state.feedList, ...action.data], // 追加数据
    hasMore: action.hasMore,
  };

// 加载失败
case 'FETCH_ERROR':
  return { ...state, loading: false, error: action.error };
```

### 面试讲解要点

1. **为什么用 useReducer 而不是 useState？**
   - 状态逻辑复杂，多个相关状态需要统一管理
   - 状态更新逻辑集中，便于维护
   - 适合有多个子状态的情况

2. **useReducer vs useState**
   - useState：适合简单状态（如单个值）
   - useReducer：适合复杂状态（如对象、多个相关状态）

---

## 📌 五、视频自动播放控制

### 代码位置：`src/components/VideoItem/VideoCard/VideoCard.js` (220-263行)

### 核心原理
使用 IntersectionObserver 监听视频元素，根据可见比例自动播放/暂停。

### 关键代码片段

```javascript
const observer = new IntersectionObserver(
  (entries) => {
    entries.forEach((entry) => {
      const ratio = entry.intersectionRatio || 0;
      
      // 离开视口：自动暂停
      if (!entry.isIntersecting) {
        if (isPlayingRef.current) {
          videoPlayer.pause();
        }
        return;
      }

      // 进入视口：可见比例超过 0.6 时自动播放
      if (!isPlayingRef.current && ratio >= 0.6) {
        videoPlayer.play();
      } else if (isPlayingRef.current && ratio <= 0.45) {
        videoPlayer.pause();
      }
    });
  },
  { 
    threshold: [0, 0.25, 0.45, 0.6, 0.7, 1], // 多个阈值
    rootMargin: '100px' // 提前加载
  }
);
```

### 面试讲解要点

1. **为什么用多个阈值？**
   - 0.6 触发播放，0.45 触发暂停
   - 使用滞后阈值避免频繁切换（播放/暂停）

2. **rootMargin 的作用**
   - 提前100px开始加载，优化用户体验
   - 用户滚动时视频已经准备好

---

## 📌 六、滚动位置恢复

### 代码位置：`src/App.js` (9-42行)

### 核心原理
使用 localStorage 保存滚动位置，页面加载时恢复。

### 关键代码片段

```javascript
function ScrollRestoration() {
  const location = useLocation();

  useEffect(() => {
    // 恢复滚动位置
    const savedPosition = getScrollPosition(location.pathname);
    if (savedPosition > 0) {
      window.scrollTo(0, savedPosition);
    }

    // 监听滚动，保存位置（防抖处理）
    const handleScroll = () => {
      saveScrollPosition(location.pathname, window.scrollY);
    };

    let scrollTimer;
    const throttledHandleScroll = () => {
      clearTimeout(scrollTimer);
      scrollTimer = setTimeout(handleScroll, 100); // 100ms防抖
    };

    window.addEventListener('scroll', throttledHandleScroll, { passive: true });
    
    return () => {
      window.removeEventListener('scroll', throttledHandleScroll);
    };
  }, [location.pathname]);
}
```

### 面试讲解要点

1. **为什么需要滚动位置恢复？**
   - 用户从详情页返回列表页时，希望回到之前的位置
   - 提升用户体验

2. **防抖的作用**
   - 滚动事件触发频繁，防抖减少存储操作
   - 提升性能

---

## 📌 七、服务层抽象

### 代码位置：`src/services/feedService.js`

### 核心原理
将API调用封装成服务层，便于复用和维护。

### 关键代码片段

```javascript
// 获取 Feed 数据
export const getFeed = async (region = 'VN', device_id, page = 1, pageSize = 10) => {
  const feedOptions = {
    method: 'GET',
    url: 'https://tiktok-all-in-one.p.rapidapi.com/feed',
    params: { region, device_id },
    headers: { /* ... */ },
  };
  return await httpRequest.get(feedOptions);
};

// 分页获取 Feed 数据（本地测试）
export const getFeedPaginated = async (page = 1, pageSize = 10, loop = true) => {
  // 从本地 JSON 文件分页返回数据
  // ...
};
```

### 面试讲解要点

1. **服务层的作用**
   - 将API调用逻辑与组件分离
   - 便于复用和维护
   - 便于测试和mock数据

2. **数据转换层**
   - 统一处理API返回的数据格式
   - 便于适配不同的数据源

---

## 📌 八、常见面试问题准备

### Q1: 如何实现无限滚动？
**回答要点**：
1. 使用 IntersectionObserver 监听底部元素
2. 当元素进入视口时，触发加载更多
3. 使用防抖机制避免频繁请求
4. 添加错误重试机制

### Q2: 如何优化长列表性能？
**回答要点**：
1. 虚拟窗口：只渲染可见区域附近的元素
2. 使用 useMemo 缓存计算结果
3. 使用 React.memo 避免不必要的渲染
4. 懒加载：按需加载数据

### Q3: useEffect 的依赖数组有什么作用？
**回答要点**：
1. 空数组 []：只在组件挂载时执行一次
2. 有依赖 [count]：依赖变化时执行
3. 无依赖：每次渲染都执行（不推荐）
4. 清理函数：在组件卸载或依赖变化前执行

### Q4: useCallback 和 useMemo 的区别？
**回答要点**：
1. useCallback：缓存函数，避免子组件不必要的渲染
2. useMemo：缓存值，避免重复计算
3. 都依赖依赖数组，依赖变化时重新计算

### Q5: 如何实现防抖和节流？
**回答要点**：
1. 防抖（debounce）：延迟执行，如果期间有新触发则重新计时
2. 节流（throttle）：固定时间间隔执行一次
3. 应用场景：搜索框输入、滚动事件、窗口resize

---

## 📌 九、项目优化方向（加分项）

如果面试官问："如果让你优化这个项目，你会怎么做？"

### 建议回答：

1. **性能优化**
   - 添加代码分割（Code Splitting）
   - 优化图片加载（懒加载、WebP格式）
   - 使用 Service Worker 缓存资源

2. **用户体验**
   - 添加骨架屏（已有）
   - 优化加载状态提示
   - 添加错误边界（Error Boundary）

3. **代码质量**
   - 添加 TypeScript
   - 添加单元测试
   - 优化代码结构

4. **功能扩展**
   - 添加搜索功能
   - 添加用户登录
   - 添加视频上传

---

## 📌 十、应急话术

### 如果问到不会的技术点：

> "这个问题我之前没有深入了解过，但我可以基于我的理解尝试回答。如果让我来解决这个问题，我会先查阅相关文档，然后通过实践来验证。"

### 如果问到项目中的技术细节不清楚：

> "这部分代码是我在学习过程中参考了一些开源项目实现的，具体的实现细节我需要再查看一下代码。但我理解它的核心原理是..."

### 如果问到算法题不会：

> "这个问题我之前没有遇到过，但我可以尝试分析一下。首先我需要理解问题的需求，然后思考可能的解决方案..."

---

## 🎯 总结

### 核心要点
1. ✅ 无限滚动：IntersectionObserver + 防抖
2. ✅ 虚拟窗口：性能优化，减少DOM节点
3. ✅ 自定义Hooks：代码复用
4. ✅ 状态管理：useReducer 管理复杂状态
5. ✅ 视频控制：IntersectionObserver 自动播放/暂停

### 面试策略
1. ✅ 诚实回答，不要夸大
2. ✅ 重点讲解你理解的部分
3. ✅ 展示学习能力和解决问题的思路
4. ✅ 准备1-2个项目难点和解决方案

**祝你面试顺利！** 🚀







